# 1주차

날짜: 2023년 1월 7일

## MySQL 전체 구조

---

### MySQL 서버 전체 구조

---

![그림 1. MySQL 서버의 전체 구조](1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%208c8035a1fff049fe8b14e406e69d9708/Untitled.png)

그림 1. MySQL 서버의 전체 구조

### MySQL 엔진

---

> 요청된 SQL 문장을 분석 또는 최적화 등 명령 처리 수행
> 
- **Connection Handler**
    - 클라이언트로부터의 접속 및 쿼리 요청을 처리
- **Optimizer**
    - SQL 파서 및 전처리기, 쿼리의 최적화된 실행 처리
- **표준 SQL 문법** 지원
    - 타 DBMS에도 쿼리 호환 가능

### 스토리지 엔진

---

> 실제 디스크 스토리지에 데이터를 저장 또는 읽어오는 기능
> 
- 스토리지 엔진은 여러 엔진을 동시 사용 가능
    - 예제 코드 ( 테이블이 사용할 스토리지 엔진 정의 방법 )
    
    ```sql
    mysql> CREATE TABLE fisrt_table (fd1 INT, fd2 INT) ENGINE=INNODB;
    mysql> CREATE TABLE second_table (fd1 INT, fd2 INT) ENGINE=MyISAM;
    ```
    
    - 지정한 스토리지 엔진(InnoDB)에서 읽기, 쓰기 등의 처리 전담

### 핸들러 API

---

> MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽을 때,
각 스토리지 엔진에 쓰기 또는 읽기를 요청하는데 사용되는 API
> 
- **MySQL 엔진과 스토리지 엔진 간의 데이터를 주고받는 API**
- API 확인 방법

```sql
mysql> SHOW GLOBAL STATUS LIKE 'Handler%';
```

## MySQL 스레딩 구조

---

<aside>
💡 MySQL 서버는 **스레드 기반** 작동

- 포그라운드 스레드
- 백그라운드 스레드
</aside>

- 실행 중인 스레드 확인 방법

```sql
mysql> SELECT thread_id, name, type, processlist_user, processlist_host
FROM performance_schema.threads ORDER BY type, thread_id
```

### 포그라운드 스레드 (클라이언트 스레드)

---

- 최소한 MySQL 서버에 접속된 **클라이언트의 수**만큼 존재
    - 클라이언트 접속 시, 스레드 캐시에서 확인
    - 없다면 새로운 포그라운드 스레드 생성
- 주로 각 클라이언트 사용자가 요청하는 **쿼리 문장 처리**
- 클라이언트 사용자가 작업을 마치고 **커넥션 종료** 시, **스레드 캐시**로 복귀
    - 단, 스레드 캐시에 일정 기준의 대기 스레드가 존재하면, 바로 종료 (일정 수만 유지)
    - 스레드 캐시에 유지 가능한 최대 스레드 개수 설정 변수 : `thread_cache_size`
- 데이터
    - 획득처 : MySQL의 데이터 버퍼 또는 캐시 (없다면 인덱스 파일 또는 디스크 데이터)
    - MyISAM 테이블 : 디스크 쓰기 작업까지 포그라운드 스레드가 처리 가능
    - InnoDB 테이블 : 데이터 버퍼 또는 캐시까지만 포그라운드 스레드가 처리 `지연된 쓰기`

> ⭐ **참고**
> 
> - MySQL : 포그라운드 스레드 = 사용자 스레드
>     - MySQL 서버에 사용자 접속 → MySQL 서버는 요청 처리를 위한 thread 생성 → 할당
>     - 포그라운드 스레드 : DBMS 앞단에서 사용자와 통신
>     - 사용자 스레드 : 사용자(Client)가 요청한 작업 처리

### 백그라운드 스레드

---

- InnoDB 기준 백그라운드 스레드 종류 (MyISAM은 큰 해당 없음)
    - 인서트 버퍼(Insert Buffer)를 병합하는 스레드
    - 로그를 디스크로 기록하는 스레드
    - InnoDB 버퍼 풀의 데이터를 디스크에 기록(쓰기)하는 스레드
    - 데이터를 버퍼로 읽어오는 스레드
    - 잠금이나 데드락을 모니터링하는 스레드
- 중요 : 로그 스레드, 쓰기 스레드
    - MySQL 5.5 버전부터 데이트 쓰기 및 읽기 스레드의 개수를 2개 이상 지정 가능
    - 시스템 변수 : `innodb_write_io_threads`  `innodb_read_io_threads`
    - 읽기 작업 : 대부분 포그라운드 스레드에서 처리 → 다량의 스레드 불필요
        - 지연 처리 가능성 없음
        - SELECT 쿼리를 실행했는데, 요청 결과가 지연되는 응답을 보내는 DBMS는 없음
    - 쓰기 작업 : 많은 작업을 백그라운드 처리
        - 일반 내장 디스크 : 2~4개
        - DAS, SAN 등 : 최적으로 사용할 수 있을 만큼 설정
        - 지연 처리 가능성 높음
    - 일반적인 상용 DBMS는 대부분 쓰기 작업을 버퍼링해 일괄 처리하는 기능 탑재
        - InnoDB
            - 위의 방식을 따름 (쓰기 작업을 버퍼를 통해 일괄 처리하는 기능)
            - 쿼리로 데이터가 변경되어도 데이터의 디스크 저장까지 기다리지 않아도 됨
        - MyISAM
            - 위 방식 대신 사용자 스레드가 쓰기 작업까지 함께 처리
            - 일반 쿼리는 쓰기 버퍼링 기능을 사용할 수 없음

## 메모리 할당 및 사용 구조

---

### 글로벌 메모리 영역

---

- MySQL 서버가 시작되면서 운영체제로부터 할당
    - MySQL의 시스템 변수로 설정해 둔 만큼 OS로부터 메모리 할당
- 사용자 스레드의 수와 무관하게 하나의 메모리 공간만 할당
    - 필요에 따라 2개 이상의 메모리 공간 할당 가능 (클라이언트 스레드 수와 무관)
    - 생성된 글로벌 영역이 N개라도 **모든 스레드에 의해 공유**
- 종류
    - 테이블 캐시
    - InnoDB 버퍼 풀
    - InnoDB 어댑티브 해시 인덱스
    - InnoDB 리두 로그 버퍼

### 로컬 메모리 영역 (세션 메모리 영역)

---

- 클라이언트 스레드가 사용자 요청 처리를 위해 사용하는 메모리 공간
    - 동어 : 클라이언트 메모리 영역, 로컬 메모리 영역, 세션 메모리 영역
- 각 클라이언트 스레드 별로 독립적으로 할당되어 **절대 공유되지 않음**
- 각 쿼리의 용도별로 **필요할 때만 공간이 할당**
    - 대표 : 소트 버퍼, 조인 버퍼 등
    - 커넥션이 열려 있는 동안 계속 할당된 상태로 남아있는 공간
        - 커넥션 버퍼, 결과 버퍼
    - 쿼리를 실행하는 순간에만 할당하다 다시 해제하는 공간
        - 소트 버퍼, 조인 버퍼
- 종류
    - 정렬 버퍼 (Sort Buffer)
    - 조인 버퍼
    - 바이너리 로그 캐시
    - 네트워크 버퍼

## 플러그인 스토리지 엔진 모델

---

### 플러그인

---

- 플러그인 형태로 개발/구현해서 사용
    - 스토리지 엔진, 검색어 파서, 사용자 인증 등
    - Native Authentication, Caching SH-2 Authentication 등
- MySQL 쿼리 실행 과정
    - **MySQL 엔진**의 처리 영역
        - SQL 파서, SQL 옵티마이저, SQL 실행기
    - **스토리지 엔진**의 처리 영역
        - 데이터 읽기/쓰기
    - 디스크

<aside>
💡 사용자가 새로운 용도의 스토리지 엔진을 개발해도

DBMS의 전체 기능이 아닌 일부분 기능만 수행하는 엔진을 개발

</aside>

### 핸들러(Handler)

> MySQL 엔진이 스토리지 엔진을 조정하기 위한 객체
> 
- 데이터 읽기/쓰기
    - MySQL 엔진 → 스토리지 엔진 : 데이터 읽기/쓰기 명령 하달
    - Handler : 명령 하달을 위해 사용하는 것
- MySQL 서버의 상태 변수
    - `Handler_` 로 시작하는 상태 변수
        - MySQL 엔진이 각 스토리지 엔진에게 보낸 명령의 횟수를 의미