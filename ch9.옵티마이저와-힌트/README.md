# ch9. 옵티마이저와 힌트

# 9.1 개요

쿼리의 결과는 동일하지만, 어떠한 과정을 거쳤는지는 천차만별이다. 대부분의 DBMS에서의 옵티마이저는 여러 과정속에서 최적의 쿼리 실행 계획을 찾아서 최소한의 비용으로 쿼리를 실행한다. 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계 정보를 참조하며, 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업을 한다.

<aside>
☝ 실행계획을 이해할 수 있어야만, 실행 계획의 불합리한 부분을 찾아내고, 더 최적화 된 방법으로 유도(힌트)를 할 수 있다.

</aside>

## 9.1.1 쿼리 실행 절차

MySQL 서버의 쿼리 실행 과정을 아래와 같이 3단계로 나눌 수 있다.

1. 사용자로부터 요청된 SQL 문장을 MySQL 서버가 이해할 수 있는 수준으로 잘게 쪼개서 분리(파스 트리)한다. (SQL 파스 트리 생성)
    1. 이 과정을 `SQL 파싱`이라고 한다.
    2. MySQL 엔진은 이 과정에서 SQL 파서 모듈을 사용한다.
2. SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다. (옵티마이저 담당)
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다. (MySQL 엔진 ↔ 스토리지 엔진, 함께 처리!)

**2 번째 단계에서는 SQL 파스 트리를 참조해 다음 작업을 처리하면서 최적화 및 실행 계획 수립을 한다.**

- 불필요한 조건 제거 및 복잡한 연산의 단순화
- 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
- 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
- 가져온 레코드들을 가공해야 하는지 결정

## 9.1.2 옵티마이저의 종류

현재 대부분의 DBMS가 선택하고 있는 비용 기반 최적화(CBO) 방법과 초기 오라클에서 많이 사용했던 규칙 기반 최적화 방법(RBO)으로 크게 나뉜다.

- 규칙 기반 최적화
    - 테이블의 레코드 수, 선택도 등을 고려하지 않음 (통계 정보 사용 X)
    - 옵티마이저의 내장된 우선순위에 따라 실행 계획 수립
    - 동일한 쿼리에 거의 동일한 실행 방법 생성
- 비용 기반 최적화
    - 하나의 쿼리에 대한 여러 가지 가능한 방법을 생성
    - 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용 산출
    - 산출된 실행 방법별 최소 비용의 처리 방식을 선택

# 9.2 기본 데이터 처리

모든 RDBMS는 데이터를 정렬하거나 그루핑하는 기본 데이터 가공 기능이 있다. 하지만 RDBMS별로 만들어내는 과정을 천차만별이다. MySQL은 어떤 알고리즘을 사용하는지 살펴보자.

## 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

다음 조건일 때 주로 풀 테이블 스캔을 사용한다.

- 테이블의 레코드 건수가 너무 작은 경우(일반적으로 테이블이 페이지 1개로 구성된 경우)
- WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 조건이 없는 경우
- 인덱스 레인지 스캔이 가능하더라도, 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우

<aside>
☝ 대부분 DBMS는 풀 테이블 스캔을 실행할 때, 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능을 내장하고 있다. → 리드 어헤드(Read ahead)

</aside>

리드 어헤드(Read ahead) 작업이란, 어떤 영역의 데이터가 앞으로 필요해질 것을 예측해서 **요청이 오기전에 미리 디스크에서 읽어**와 InnoDB **버퍼 풀에 가져다 두는 것**을 의미한다.

InnoDB 스토리지 엔진은 다음과 같은 상황에서 `리드 어헤드`를 작동시킨다.

1. 풀 테이블 스캔이 시작되고, 처음 몇 개의 데이터 페이지는 포그라운드 스레드에서 처리한다.
2. 특정 테이블의 연속된 데이터 페이지가 읽히면, 읽기 작업을 백그라운드 스레드로 넘긴다.
3. 이 시점부터는 한번에 4개 또는 6개씩 페이지를 읽으면서 점점 증가시킨다. (최대 64개 페이지)